
# -----------------------------------------------------------------------------
# Imported types

using ControlSystems
using AbstractTrees
# using Infiltrator



#------------------------------------------------------------------------------
# Declared types

dB10(x) = 10*log10(x)
dB20(x) = 2*dB10(x)

export PLL

struct PLL
	name::String
	description::String
	input::Vector{Block}
	forward::Vector{Block}
	feedback::Vector{Block}
	output::Vector{Block}

	function PLL(name::String, description::String="",
		input::Vector{Block}=Block[], forward::Vector{Block}=Block[],
		feedback::Vector{Block}=Block[], output::Vector{Block}=Block[])
		new(name, description, input, forward, feedback, output)
	end
end

function PLL()
	fref = 80e6
	Nref = 8
	Icp = 1e-3
	Kvco = 10e6
	Nmmd = 2e9*Nref/fref
	Nout = 2
	ref = pllref("80MHz reference clock", PinkNoise("Reference noise",[100,1e6,1e8,1e9],[-20,-130.0,-160.0,-170.0]))
	rdiv = plldiv("Reference divider", Nref, WhiteNoise("Reference divider noise", 10^-13))
	pfd = pllgain("PFD", 1/(2*pi), WhiteNoise("PFD noise", 10^-12))
	chp = pllgain("Charge-pump", Icp, WhiteNoise("Charge-pump noise", 10^-18))
	# lpf = pllfilter("LPF", [9225,8547], [19,540,19]*1e-12)
	lpf, = pllfilter("LPF", Icp*Kvco/Nmmd, 100e3, 53, 300, 0.2)
	vco = pllvco("2GHz VCO", Kvco, PinkNoise("VCO noise",[100,1e6,1e8,1e9],[0.0,-110.0,-140.0,-145.0]))
	mmd = pllmmd("MMD", fref/Nref, Nmmd, 3)
	odiv = plldiv("Output divider", Nout, WhiteNoise("Output divider noise", 10^-13))
	pll = PLL("Example PLL model", "Generated by the PllToolbox module")
	addinput!(pll, ref, rdiv)
	addforward!(pll, pfd, chp, lpf, vco)
	addfeedback!(pll, mmd)
	addoutput!(pll, odiv)
	# fref = 1e6
	# Nref = 1
	# Icp = 1e-3
	# Kvco = 1e6
	# Nmmd = 103
	# Nout = 1
	# ref = pllref("80MHz reference clock", PinkNoise("Reference noise",[100,1e6,1e8,1e9],[-20,-130.0,-160.0,-170.0]))
	# rdiv = plldiv("Reference divider", Nref, WhiteNoise("Reference divider noise", 10^-13))
	# pfd = pllgain("PFD", 1/(2*pi), WhiteNoise("PFD noise", 10^-12))
	# chp = pllgain("Charge-pump", Icp, WhiteNoise("Charge-pump noise", 10^-15))
	# lpf, = pllfilter("LPF", [1e3], [1.0,100.0]*1e-9)
	# vco = pllvco("2GHz VCO", Kvco, PinkNoise("VCO noise",[100,1e6,1e8,1e9],[0.0,-110.0,-140.0,-145.0]))
	# mmd = pllmmd("MMD", fref/Nref, Nmmd, 3)
	# odiv = plldiv("Output divider", Nout, WhiteNoise("Output divider noise", 10^-13))
	# pll = PLL("Example PLL model", "Generated by the PllToolbox module")
	# addinput!(pll, ref, rdiv)
	# addforward!(pll, pfd, chp, lpf, vco)
	# addfeedback!(pll, mmd)
	# addoutput!(pll, odiv)
	return pll
end

function Base.show(io::IO, x::PLL)
	println(io, "PLL structure")
	println(io, "    name: $(x.name)")
	if length(x.input)>0
		println(io, "    input blocks:")
		for b in x.input
			println(io, "        $(b.name)")
		end
	else
		println(io, "    input blocks: none")
	end
	if length(x.forward)>0
		println(io, "    forward blocks:")
		for b in x.forward
			println(io, "        $(b.name)")
		end
	else
		println(io, "    forward blocks: none")
	end
	if length(x.feedback)>0
		println(io, "    feedback blocks:")
		for b in x.feedback
			println(io, "        $(b.name)")
		end
	else
		println(io, "    feedback blocks: none")
	end
	if length(x.output)>0
		println(io, "    output blocks:")
		for b in x.output
			println(io, "        $(b.name)")
		end
	else
		println(io, "    output blocks: none")
	end
end


struct PathNode
	name::String
	children::Vector{Block}
end

function AbstractTrees.children(node::PLL)
	(
		PathNode("Input", node.input),
		PathNode("Forward", node.forward),
		PathNode("Feedback", node.feedback),
		PathNode("Output", node.output)
	)
end
AbstractTrees.children(node::PathNode) = node.children
AbstractTrees.printnode(io::IO, node::PLL) = print(io, node.name)
AbstractTrees.printnode(io::IO, node::PathNode) = print(io, node.name)

export addinput!
addinput!(pll::PLL, b::Block...) = push!(pll.input,b...)

export addforward!
addforward!(pll::PLL, b::Block...) = push!(pll.forward, b...)

export addfeedback!
addfeedback!(pll::PLL, b::Block...) = push!(pll.feedback, b...)

export addoutput!
addoutput!(pll::PLL, b::Block...) = push!(pll.output, b...)
